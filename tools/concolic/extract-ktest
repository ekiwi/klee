#!/usr/bin/env python3

# ===-- ktest-tool --------------------------------------------------------===##
# 
#                      The KLEE Symbolic Virtual Machine
# 
#  This file is distributed under the University of Illinois Open Source
#  License. See LICENSE.TXT for details.
# 
# ===----------------------------------------------------------------------===##

import os, struct, sys, argparse, glob

version_no=3

class KTestError(Exception):
	pass

class KTest:
	@staticmethod
	def fromfile(path):
		if not os.path.exists(path):
			print("ERROR: file %s not found" % (path))
			sys.exit(1)

		f = open(path,'rb')
		hdr = f.read(5)
		if len(hdr) != 5 or (hdr != b'KTEST' and hdr != b"BOUT\n"):
			raise KTestError('unrecognized file: "{}"'.format(path))
		version, = struct.unpack('>i', f.read(4))
		if version > version_no:
			raise KTestError('unrecognized version')
		numArgs, = struct.unpack('>i', f.read(4))
		args = []
		for i in range(numArgs):
			size, = struct.unpack('>i', f.read(4))
			args.append(str(f.read(size).decode(encoding='ascii')))

		if version >= 2:
			symArgvs, = struct.unpack('>i', f.read(4))
			symArgvLen, = struct.unpack('>i', f.read(4))
		else:
			symArgvs = 0
			symArgvLen = 0

		numObjects, = struct.unpack('>i', f.read(4))
		objects = {}
		for i in range(numObjects):
			size, = struct.unpack('>i', f.read(4))
			name = f.read(size)
			size, = struct.unpack('>i', f.read(4))
			bytes = f.read(size)
			objects[name] = bytes

		# Create an instance
		b = KTest(version, args, symArgvs, symArgvLen, objects)
		# Augment with extra filename field
		b.filename = path
		b.testnum = int(os.path.splitext(os.path.basename(path))[0][4:])
		return b

	def __init__(self, version, args, symArgvs, symArgvLen, objects):
		self.version = version
		self.symArgvs = symArgvs
		self.symArgvLen = symArgvLen
		self.args = args
		self.objects = objects

		# add a field that represents the name of the program used to
		# generate this .ktest file:
		program_full_path = self.args[0]
		program_name = os.path.basename(program_full_path)
		# sometimes program names end in .bc, so strip them
		if program_name.endswith('.bc'):
			program_name = program_name[:-3]
		self.programName = program_name

def trimZeros(str):
	for i in range(len(str))[::-1]:
		if str[i] != '\x00':
			return str[:i+1]
	return ''

def main(args):
	parser = argparse.ArgumentParser(description='extract raw stdin input from ktest file(s)')
	parser.add_argument('-o','--output', dest='output', required=True, help='output folder')
	parser.add_argument('ktest', nargs='+', help='ktest file(s)')

	args = parser.parse_args()
	if not args or not os.path.isdir(args.output):
		parser.print_help()
		exit(1)

	extract_count = 0
	for inp in args.ktest:
		if os.path.isdir(inp):
			files = glob.iglob(os.path.join(inp, "*.ktest"))
		else:
			files = [inp]
		for fin in files:
			b = KTest.fromfile(fin)
			assert(b'stdin' in b.objects)
			filename = "test{:07}.in".format(b.testnum)
			with open(os.path.join(args.output, filename), 'wb') as ff:
				ff.write(trimZeros(b.objects[b'stdin']))
			extract_count += 1
	print("extraced {} tests".format(extract_count))


if __name__=='__main__':
	main(sys.argv)
